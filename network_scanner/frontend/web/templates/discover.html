{% extends "base.html" %}

{% block title %}Discover Devices - Network Scanner{% endblock %}

{% block page_title %}Discover Devices{% endblock %}

{% block content %}
[Previous HTML content remains exactly the same until script tag]

{% block scripts %}
<script>
// Debug logger utility
const logger = {
    styles: {
        title: 'font-weight: bold; font-size: 12px; padding: 2px 5px; border-radius: 3px; margin-right: 5px;',
        info: 'background: #3498db; color: white;',
        success: 'background: #2ecc71; color: white;',
        warning: 'background: #f1c40f; color: white;',
        error: 'background: #e74c3c; color: white;'
    },
    
    formatData: function(data) {
        if (typeof data === 'object' && data !== null) {
            return JSON.stringify(data, null, 2)
                .split('\n')
                .map(line => '    ' + line)
                .join('\n');
        }
        return data;
    },
    
    info: function(title, ...args) {
        console.log(
            `%c${title}`,
            this.styles.title + this.styles.info,
            ...args.map(arg => this.formatData(arg))
        );
    },
    
    success: function(title, ...args) {
        console.log(
            `%c${title}`,
            this.styles.title + this.styles.success,
            ...args.map(arg => this.formatData(arg))
        );
    },
    
    warn: function(title, ...args) {
        console.warn(
            `%c${title}`,
            this.styles.title + this.styles.warning,
            ...args.map(arg => this.formatData(arg))
        );
    },
    
    error: function(title, ...args) {
        console.error(
            `%c${title}`,
            this.styles.title + this.styles.error,
            ...args.map(arg => this.formatData(arg))
        );
    }
};

// Global state
let deviceCache = [];
let scanPaused = false;
let currentPollTimeout = null;

// Utility functions
function isValidDevice(device) {
    return device &&
        typeof device === 'object' &&
        typeof device.ip === 'string' &&
        device.ip.length > 0 &&
        typeof device.status === 'string' &&
        ['up', 'down', 'unreachable'].includes(device.status.toLowerCase());
}

function mergeDevices(existingDevices, newDevices) {
    if (!Array.isArray(existingDevices) || !Array.isArray(newDevices)) {
        logger.error('‚ùå Device Arrays Invalid', { existingDevices, newDevices });
        return Array.isArray(existingDevices) ? existingDevices : [];
    }

    const deviceMap = new Map(
        existingDevices
            .filter(isValidDevice)
            .map(device => [device.ip, device])
    );

    newDevices
        .filter(isValidDevice)
        .forEach(device => {
            const existing = deviceMap.get(device.ip);
            if (!existing || 
                (device.timestamp && (!existing.timestamp || 
                new Date(device.timestamp) > new Date(existing.timestamp)))) {
                deviceMap.set(device.ip, device);
            }
        });

    return Array.from(deviceMap.values());
}

function getStatusBadgeColor(status) {
    status = (status || '').toLowerCase();
    switch (status) {
        case 'up': return 'success';
        case 'down': return 'danger';
        case 'unreachable': return 'warning';
        default: return 'secondary';
    }
}

function formatTimestamp(timestamp) {
    if (!timestamp) return 'N/A';
    try {
        return new Date(timestamp).toLocaleString();
    } catch (error) {
        logger.warn('‚ö†Ô∏è Invalid Timestamp', timestamp);
        return 'Invalid Date';
    }
}

// Display functions
function displayResults(devices) {
    const tableBody = document.querySelector('#results-table tbody');
    
    if (!Array.isArray(devices) || devices.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" class="text-center">No devices found.</td></tr>';
        return;
    }
    
    tableBody.innerHTML = '';
    deviceCache = devices;
    
    devices.forEach(device => {
        if (!isValidDevice(device)) {
            logger.warn('‚ö†Ô∏è Invalid Device', device);
            return;
        }

        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${device.ip}</td>
            <td><span class="badge bg-${getStatusBadgeColor(device.status)}">${device.status}</span></td>
            <td>${device.method || 'N/A'}</td>
            <td>${device.info || 'N/A'}</td>
            <td>${formatTimestamp(device.timestamp)}</td>
            <td>
                <div class="btn-group btn-group-sm">
                    <button type="button" class="btn btn-outline-primary scan-ports" data-ip="${device.ip}">
                        <i class="bi bi-hdd-network"></i>
                    </button>
                    <button type="button" class="btn btn-outline-info fingerprint" data-ip="${device.ip}">
                        <i class="bi bi-fingerprint"></i>
                    </button>
                    <button type="button" class="btn btn-outline-danger nmap-scan" data-ip="${device.ip}">
                        <i class="bi bi-shield-check"></i>
                    </button>
                </div>
            </td>
        `;
        tableBody.appendChild(row);
    });
    
    // Add event listeners
    ['scan-ports', 'fingerprint', 'nmap-scan'].forEach(action => {
        document.querySelectorAll(`.${action}`).forEach(button => {
            button.addEventListener('click', function() {
                const ip = this.getAttribute('data-ip');
                window.location.href = `/${action.split('-')[0]}?target=${ip}`;
            });
        });
    });

    logger.info('üìä Results Updated', {
        totalDevices: devices.length,
        statuses: devices.reduce((acc, dev) => {
            acc[dev.status] = (acc[dev.status] || 0) + 1;
            return acc;
        }, {})
    });
}

function exportResults(format) {
    if (!deviceCache.length) {
        showAlert('No results to export', 'warning');
        return;
    }
    
    let content, filename, mimeType;
    
    if (format === 'csv') {
        const headers = ['IP Address', 'Status', 'Method', 'Device Info', 'Last Seen'];
        content = [
            headers.join(','),
            ...deviceCache.map(device => [
                device.ip,
                device.status,
                device.method || 'N/A',
                device.info || 'N/A',
                formatTimestamp(device.timestamp)
            ].join(','))
        ].join('\n');
        filename = `network-scan-${new Date().toISOString().split('T')[0]}.csv`;
        mimeType = 'text/csv';
    } else {
        content = JSON.stringify(deviceCache, null, 2);
        filename = `network-scan-${new Date().toISOString().split('T')[0]}.json`;
        mimeType = 'application/json';
    }
    
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    logger.success('üì• Export Complete', { format, filename });
    showAlert(`Results exported to ${filename}`, 'success');
}

// Scanning functions
function pollForResults(target, timeout) {
    const scanStatus = document.getElementById('scan-status');
    const scanButton = document.getElementById('scan-button');
    const pauseButton = document.getElementById('pause-scan');
    
    pauseButton.disabled = false;
    document.getElementById('resume-scan').disabled = true;
    
    if (target.includes('/24')) {
        timeout = Math.max(timeout, 10.0);
        logger.info('‚öôÔ∏è Scan Config', `Adjusted network scan timeout to ${timeout}s`);
    }
    
    const pollInterval = Math.max(1000, Math.min(2000, timeout * 300));
    const maxPollingDuration = timeout * 8000;
    const startTime = Date.now();
    let lastPollTime = 0;
    
    function checkResults() {
        if (scanPaused) {
            logger.info('‚è∏Ô∏è Scan Status', 'Paused');
            return;
        }
        
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(99, Math.round((elapsedTime / maxPollingDuration) * 100));
        
        const timeSinceLastPoll = Date.now() - lastPollTime;
        if (timeSinceLastPoll < 1000) {
            currentPollTimeout = setTimeout(checkResults, 1000 - timeSinceLastPoll);
            return;
        }
        
        lastPollTime = Date.now();
        
        fetch('/api/discover', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                target,
                timeout: 2.0,
                passive: document.getElementById('passive').checked,
                stealth: document.getElementById('stealth').checked,
                deep: document.getElementById('deep-scan').checked
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.data) {
                const validDevices = data.data.filter(isValidDevice);
                if (validDevices.length > 0) {
                    logger.success('‚ú® Devices Found', {
                        target,
                        count: validDevices.length,
                        devices: validDevices.map(d => d.ip)
                    });
                    deviceCache = mergeDevices(deviceCache, validDevices);
                    displayResults(deviceCache);
                }
                
                scanStatus.innerHTML = `
                    <div class="d-flex flex-column">
                        <div class="d-flex align-items-center mb-2">
                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                            <div>Found ${deviceCache.length} devices (${Math.round(elapsedTime/1000)}s)</div>
                        </div>
                        <div class="progress" style="height: 5px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: ${progress}%"></div>
                        </div>
                    </div>
                `;
                
                if (elapsedTime < maxPollingDuration) {
                    currentPollTimeout = setTimeout(checkResults, pollInterval);
                } else {
                    scanComplete();
                }
            }
        })
        .catch(error => {
            logger.error('‚ùå Polling Error', error);
            if (elapsedTime < maxPollingDuration) {
                currentPollTimeout = setTimeout(checkResults, pollInterval * 2);
            } else {
                scanComplete();
            }
        });
    }
    
    logger.info('üîÑ Starting Poll', {
        target,
        interval: pollInterval,
        maxDuration: maxPollingDuration
    });
    
    currentPollTimeout = setTimeout(checkResults, 1000);
}

function scanComplete(success = true, message = '') {
    const scanStatus = document.getElementById('scan-status');
    const scanButton = document.getElementById('scan-button');
    const pauseButton = document.getElementById('pause-scan');
    
    scanStatus.classList.add('d-none');
    scanButton.disabled = false;
    pauseButton.disabled = true;
    document.getElementById('resume-scan').disabled = true;
    
    if (success) {
        if (deviceCache.length > 0) {
            logger.success('‚úÖ Scan Complete', {
                devicesFound: deviceCache.length
            });
            showAlert(`Scan complete. Found ${deviceCache.length} devices.`, 'success');
        } else {
            logger.warn('‚ö†Ô∏è No Devices', 'Scan completed but no devices were found');
            showAlert('No devices found. Try a different network or increase the timeout.', 'warning');
        }
    } else {
        logger.error('‚ùå Scan Failed', message);
        showAlert(message || 'Error during scan', 'danger');
    }
}

// Event handlers
document.getElementById('pause-scan').addEventListener('click', function() {
    scanPaused = true;
    this.disabled = true;
    document.getElementById('resume-scan').disabled = false;
    
    if (currentPollTimeout) {
        clearTimeout(currentPollTimeout);
    }
    
    logger.info('‚è∏Ô∏è Scan Control', 'Scan paused by user');
    showAlert('Scan paused. Click Resume to continue.', 'info');
});

document.getElementById('resume-scan').addEventListener('click', function() {
    scanPaused = false;
    this.disabled = true;
    document.getElementById('pause-scan').disabled = false;
    
    logger.info('‚ñ∂Ô∏è Scan Control', 'Scan resumed by user');
    checkResults();
    showAlert('Scan resumed', 'info');
});

document.getElementById('batch-mode').addEventListener('change', function() {
    const target = document.getElementById('target');
    if (this.checked) {
        target.setAttribute('placeholder', 'Enter multiple networks (one per line)');
        target.style.height = '100px';
        target.removeAttribute('pattern');
    } else {
        target.setAttribute('placeholder', 'IP, range, or CIDR (e.g., 192.168.1.0/24)');
        target.style.height = '';
        target.setAttribute('pattern', '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:/(?:3[0-2]|[1-2]?[0-9]))?$');
    }
});

document.getElementById('discover-form').addEventListener('submit', async function(event) {
    event.preventDefault();
    
    const target = document.getElementById('target').value;
    const timeout = parseFloat(document.getElementById('timeout').value);
    const batchMode = document.getElementById('batch-mode').checked;
    
    scanPaused = false;
    document.getElementById('pause-scan').disabled = false;
    document.getElementById('resume-scan').disabled = true;
    
    const scanStatus = document.getElementById('scan-status');
    const scanButton = document.getElementById('scan-button');
    
    scanStatus.classList.remove('d-none');
    scanButton.disabled = true;
    
    if (batchMode) {
        const targets = target.split('\n')
            .map(t => t.trim())
            .filter(t => t.length > 0);
        
        if (targets.length === 0) {
            showAlert('Please enter at least one target', 'warning');
            return;
        }
        
        logger.info('üéØ Batch Scan Start', {
            targets: targets.length,
            timeout,
            mode: {
                passive: document.getElementById('passive').checked,
                stealth: document.getElementById('stealth').checked,
                deep: document.getElementById('deep-scan').checked
            }
        });
        
        showAlert(`Starting batch scan of ${targets.length} targets`, 'info');
        processBatchTargets(targets);
        return;
    }
    
    try {
        scanHistory.addNetwork(target);
        logger.info('üéØ Single Scan Start', {
            target,
            timeout,
            mode: {
                passive: document.getElementById('passive').checked,
                stealth: document.getElementById('stealth').checked,
                deep: document.getElementById('deep-scan').checked
            }
        });
        
        const response = await fetch('/api/discover', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                target,
                timeout,
                passive: document.getElementById('passive').checked,
                stealth: document.getElementById('stealth').checked,
                deep: document.getElementById('deep-scan').checked
            })
        });
        
        const data = await response.json();
        if (data.success) {
            pollForResults(target, timeout);
        } else {
            scanComplete(false, data.message);
        }
    } catch (error) {
        scanComplete(false, error.message);
        logger.error('‚ùå Scan Error', error);
    }
});

// Batch scanning function
function processBatchTargets(targets) {
    let currentIndex = 0;
    let batchDevices = [];
    const totalTargets = targets.length;
    const scanStatus = document.getElementById('scan-status');

    async function scanNext() {
        if (scanPaused) {
            logger.info('‚è∏Ô∏è Batch Scan', 'Paused at target ' + (currentIndex + 1));
            return;
        }

        if (currentIndex >= totalTargets) {
            logger.success('‚úÖ Batch Scan', {
                complete: true,
                totalScanned: totalTargets,
                devicesFound: batchDevices.length
            });
            scanComplete(true);
            return;
        }

        const target = targets[currentIndex];
        const progress = Math.round((currentIndex / totalTargets) * 100);
        
        logger.info('üîÑ Processing Target', {
            current: currentIndex + 1,
            total: totalTargets,
            target,
            progress: `${progress}%`
        });
        
        scanStatus.innerHTML = `
            <div class="d-flex flex-column">
                <div class="d-flex align-items-center mb-2">
                    <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                    <div>Scanning target ${currentIndex + 1}/${totalTargets}: ${target}</div>
                </div>
                <div class="progress" style="height: 5px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: ${progress}%"></div>
                </div>
            </div>
        `;

        try {
            const response = await fetch('/api/discover', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    target,
                    timeout: parseFloat(document.getElementById('timeout').value),
                    passive: document.getElementById('passive').checked,
                    stealth: document.getElementById('stealth').checked,
                    deep: document.getElementById('deep-scan').checked
                })
            });

            const data = await response.json();
            if (data.success && data.data) {
                const validDevices = data.data.filter(isValidDevice);
                if (validDevices.length > 0) {
                    batchDevices = mergeDevices(batchDevices, validDevices);
                    displayResults(batchDevices);
                    logger.success('‚ú® Target Results', {
                        target,
                        found: validDevices.length,
                        totalSoFar: batchDevices.length
                    });
                }
            }
        } catch (error) {
            logger.error('‚ùå Target Failed', {
                target,
                error: error.message,
                progress: `${progress}%`
            });
            showAlert(`Error scanning ${target}: ${error.message}`, 'warning');
        }

        currentIndex++;
        if (!scanPaused) {
            setTimeout(scanNext, 1000);
        }
    }

    scanNext();
}

// Network detection functions
function detectNetwork() {
    const networkInfo = document.getElementById('network-info');
    networkInfo.innerHTML = '<p>Detecting your network...</p>';
    
    const commonGateways = [
        '192.168.31.254',
        '192.168.1.254',
        '192.168.0.1',
        '192.168.1.1'
    ];
    
    logger.info('üîç Network Detection', 'Starting gateway detection');
    
    async function tryNextGateway(index = 0) {
        if (index >= commonGateways.length) {
            logger.warn('‚ö†Ô∏è Network Detection', 'No gateway found, suggesting common networks');
            suggestCommonNetworks();
            return;
        }
        
        const gateway = commonGateways[index];
        logger.info('üåê Checking Gateway', gateway);
        
        try {
            const response = await fetch('/api/discover', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    target: gateway,
                    timeout: 2.0,
                    stealth: false
                })
            });
            
            const data = await response.json();
            if (data.success && data.data?.[0]) {
                const device = data.data[0];
                if (isValidDevice(device)) {
                    const parts = device.ip.split('.');
                    const network = `${parts[0]}.${parts[1]}.${parts[2]}.0/24`;
                    
                    logger.success('‚úÖ Gateway Found', {
                        gateway: device.ip,
                        network: network
                    });
                    
                    networkInfo.innerHTML = `
                        <p><strong>Gateway Found:</strong> ${device.ip}</p>
                        <p><strong>Suggested Network:</strong> ${network}</p>
                        <button type="button" class="btn btn-sm btn-success" onclick="useNetwork('${network}')">
                            Use This Network
                        </button>
                    `;
                    document.getElementById('target').value = network;
                    return;
                }
            }
            await tryNextGateway(index + 1);
        } catch (error) {
            logger.error('‚ùå Gateway Check Failed', {
                gateway,
                error: error.message
            });
            await tryNextGateway(index + 1);
        }
    }
    
    function suggestCommonNetworks() {
        networkInfo.innerHTML = `
            <p>Could not detect your network automatically.</p>
            <p>Try one of these common networks:</p>
            <div class="btn-group-vertical w-100">
                <button type="button" class="btn btn-outline-primary mb-1" onclick="useNetwork('192.168.1.0/24')">
                    192.168.1.0/24
                </button>
                <button type="button" class="btn btn-outline-primary mb-1" onclick="useNetwork('192.168.0.0/24')">
                    192.168.0.0/24
                </button>
                <button type="button" class="btn btn-outline-primary mb-1" onclick="useNetwork('192.168.31.0/24')">
                    192.168.31.0/24
                </button>
                <button type="button" class="btn btn-outline-primary" onclick="useNetwork('192.168.22.0/24')">
                    192.168.22.0/24
                </button>
            </div>
        `;
    }
    
    tryNextGateway();
}

function useNetwork(network) {
    document.getElementById('target').value = network;
    if (network.includes('/24')) {
        document.getElementById('timeout').value = '10.0';
        logger.info('‚öôÔ∏è Network Selected', {
            network,
            timeout: '10.0'
        });
    }
}

document.getElementById('detect-network').addEventListener('click', detectNetwork);

// Scan history management
const scanHistory = {
    maxHistory: 10,
    storageKey: 'networkScanHistory',
    
    getHistory() {
        try {
            return JSON.parse(localStorage.getItem(this.storageKey) || '[]');
        } catch {
            return [];
        }
    },
    
    addNetwork(network) {
        const history = this.getHistory();
        const newEntry = {
            network,
            timestamp: new Date().toISOString()
        };
        
        const updated = [
            newEntry,
            ...history.filter(item => item.network !== network)
        ].slice(0, this.maxHistory);
        
        localStorage.setItem(this.storageKey, JSON.stringify(updated));
        this.updateHistoryDropdown();
        
        logger.info('üìù History Updated', {
            added: network,
            total: updated.length
        });
    },
    
    updateHistoryDropdown() {
        const menu = document.getElementById('network-history');
        const history = this.getHistory();
        
        menu.innerHTML = `
            <li><h6 class="dropdown-header">Recent Networks</h6></li>
            <li><hr class="dropdown-divider"></li>
            ${history.length ? 
                history.map(item => `
                    <li>
                        <a class="dropdown-item" href="#" onclick="useNetwork('${item.network}'); return false;">
                            ${item.network}
                            <small class="text-muted d-block">
                                ${new Date(item.timestamp).toLocaleString()}
                            </small>
                        </a>
                    </li>
                `).join('') :
                '<li><span class="dropdown-item disabled">No recent networks</span></li>'
            }
        `;
    }
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    logger.info('üöÄ Application Start', 'Initializing network scanner');
    detectNetwork();
    scanHistory.updateHistoryDropdown();
});
</script>
{% endblock %}
